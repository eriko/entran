#!/usr/bin/env ruby
require 'gli'
#begin # XXX: Remove this begin/rescue before distributing your app
require 'entran'
require 'faraday'
require 'yaml'
require 'csv'
require 'open-uri'
require 'nokogiri'
require 'csv'
#require 'openssl'
require 'net/http/post/multipart'
require 'canvas-api'
#require 'pry'
require 'pandarus'

require 'zip'
#rescue LoadError
#  STDERR.puts "In development, you need to use `bundle exec bin/entran` to run your app"
#  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
#  STDERR.puts "Feel free to remove this message from bin/entran now"
#  exit 64
#end
#config_file '.entran.rc'

module Net
  class HTTP
    alias_method :original_use_ssl=, :use_ssl=

    def use_ssl=(flag)
      #self.ca_file = Rails.root.join('lib/ca-bundle.crt')
      self.verify_mode = OpenSSL::SSL::VERIFY_NONE
      self.original_use_ssl = flag
    end
  end
end

module Wrapper
  include GLI::App

  extend self
  puts Time.now
  include GLI::App
  program_desc 'Translates enrollment data into various formats and feeds it to target systems'

  config_file '.entran.rc'

  puts config_file '.entran.rc'

  version Entran::VERSION

  desc 'debug disables any changes to edge systems'
  switch [:d, :debug]


  desc 'all users from ims file and not limited to request courses'
  switch [:f, :full]

  flag [:h, :hostname]
  flag [:t, :token]
  flag [:p, :presence]
  flag [:k, :presence_key]
  flag [:i, :ims_key]
  flag [:c, :canvas_key]
  flag [:b, :banner_host]
  flag [:y, :year]

  desc 'Enrollment work for Canvas'
  command :canvas do |c|


    c.action do |global_options, options, args|

      # Your command logic here

      # If you have any errors, just raise them
      # raise "that command made no sense"
      puts global_options


      token = global_options[:t]
      hostname = global_options[:h]
      puts hostname
      client = Pandarus::Client.new(
          prefix: "https://#{hostname}/api",
          token: token)

      #canvas = Canvas::API.new(:host => "https://#{hostname}", :token => token)

      files = Hash.new
      puts "----------------->loading feed files"
      load_files(files, 'canvas', global_options[:p], global_options[:i], global_options[:b], global_options[:y])

      @users = Hash.new
      puts "----------------->importing faculty"
      files[:offerings_xml].xpath("//faculty").each { |fac| Person.import_faculty_xml(fac, @users) }
      puts "----------------->total faculty: #{@users.count}"

      puts "----------------->importing terms"
      @terms = Term.import_xml files[:terms_xml], files[:lms_courses].xpath("//current_curricular_year").text.to_i
      #puts "----------------->importing users"
      #@users = Hash.new

      @enrollments_canvas = Set.new

      puts "----------------->extract settings from lms file"
      @settings = Settings.new(@lms_courses_xml)

      puts "----------------->importing sections"
      @sections = Section.import_xml files[:lms_courses], "CanvasCourse"
      @sections_csv = Section.sections_canvas_csv(@sections)
      puts "----------------->imported sections "

      puts "----------------->importing courses"
      @courses = Course.import_xml files[:lms_courses], "CanvasCourse", @sections, @users, @terms

      puts "----------------->extract settings from lms file"
      @settings = Settings.new(files[:lms_courses])

      #binding.pry
      puts "----------------->importing accounts"
      @accounts = Account.import_xml(files[:lms_courses], client)
     #puts @accounts
      @accounts_csv = Account.accounts_canvas_csv(@accounts)
     #puts @accounts_csv
      #puts @courses
      #get people and enrollments


      puts "ene----->creating enrollments"
      @courses.values.each do |course|
        puts "ene---------->working on: #{course.long_name}"
        #course_created?(course.course_id,global_options)
        @enrollments_canvas = Enrollment.import_xml course, @enrollments_canvas, @users, global_options[:i], global_options[:b]
        puts "ene-------------------->course enrollments count: #{course.enrollments.count}"
      end

      unless global_options[:f]
        puts "enu----------------->limiting users to requested courses"
        @users_csv = Person.users_limited_canvas_csv(@enrollments_canvas)
      else
        puts "enu----------------->using all users from enrollment source"
        @users_csv = Person.users_canvas_csv(@users)
      end

      @courses.values.each do |course|
        unless course.kind.eql? 'Crosslist'
          course.status_check(global_options, client)
          puts "enc----------------->/api/v1/courses/sis_course_id:#{course.course_id}"
          begin
            unless course.created
              puts "enc----------------->Creating course that does not exist"
              puts "enc----------------->the offering course #{course.long_name.strip} does not exist so we are going to make it"
              puts "enc----------------->/api/v1/accounts/#{course.account_id}/courses"
              c_course = client.create_new_course("sis_account_id:#{course.account_id}",
                                                  {
                                                      'course__sis_course_id__' => course.course_id,
                                                      'course__name__' => course.long_name,
                                                      'course__course_code__' => course.short_name,
                                                      'course__start_at__' => course.first_term.start_date.iso8601,
                                                      'course__allow_student_forum_attachments__' => true,
                                                      'course__term_id__' => "sis_term_id:#{course.real_term}",

                                                  }
              )
              #clone the template course over to the generated one
              ccmc = client.create_content_migration_courses(c_course['id'],
                                                             'course_copy_importer',
                                                             settings__source_course_id__: @settings.canvas_templates[course.canvas_template])

              migration_id = ccmc['progress_url'].split('/')[-1]

              until client.query_progress(migration_id)['workflow_state'].eql? "completed"
                sleep(1.0/24.0)
              end

              puts "enc----------------->#{c_course}"
              #client.update_course_settings(c_course['id'],
              #                              {allow_student_discussion_topic: true,
              #                               allow_student_forum_attachments: true,
              #                               allow_student_discussion_editing: true,
              #                               allow_student_organized_groups: true}
              #)
              #mark course created in presence
              open("http://#{global_options[:p]}/feeds/canvas_created/#{global_options[:k]}/#{course.website_id}/#{c_course["id"]}") { |f|
                f.each_line { |line| p "enc----------->#{line}" }
              }
              course.created = true
            end
          rescue Canvas::ApiError => error
            if error.to_s.include?('is already in use')
              puts "enc----------------->The course already existed but was deleted without changing the sis id #{error}"
              open("http://#{global_options[:p]}/feeds/canvas_blocked/#{global_options[:k]}/#{course.website_id}") { |f|
                f.each_line { |line| p "enc----------->#{line}" }
              }
            end
          end
        end
      end
      @enrollments_canvas_csv = Enrollment.enrollments_canvas_csv(@enrollments_canvas)
      puts "ene-------------->enrollments: #{@enrollments_canvas.count}"
      #puts @enrollments_canvas_csv

      if global_options[:d]
        puts "----------------->debug mode so not talking to canvas host"
      else
        sis_data = {}
        sis_data[:users] = @users_csv
        sis_data[:terms] = files[:terms_csv].string
        sis_data[:sections] = @sections_csv
        sis_data[:accounts] = @accounts_csv
        sis_data[:enrollments] = @enrollments_canvas_csv
        #binding.pry
        send_sis(sis_data, client)


      end

      puts "ensu------------>Processing courses for setup"
      @courses.values.each do |course|
        #the api can error out so we create each area separetely and mark each one
        #as worked on before starting to do the work so that at worst there is
        #something incomplete and not repeatly pounded on. If everything is marked assert_equal
        #as setup_* = true then mark the whole thing as setup.
        #binding.pry
        unless course.setup
          puts "ensu------------>/api/v1/courses/sis_course_id:#{course.course_id}"
          puts "ensu------------>course.created == #{course.created} && course.setup == #{course.setup}"
          #binding.pry
          begin
            c_course = client.get_single_course_courses("sis_course_id:#{course.course_id}")
            puts c_course
            if c_course.id && course.created == true && course.setup == false
              puts "ensu------------>setup frontpage = #{course.setup_frontpage}"
              unless course.setup_frontpage
                open("http://#{global_options[:p]}/feeds/canvas_setup_frontpage/#{global_options[:k]}/#{course.website_id}") { |f|
                  f.each_line { |line| p line }
                }
                course.create_frontpage(client, c_course)
                course.setup_frontpage = true
              end
              #create modules
              puts "ensu------------>course.setup_modules = #{course.setup_modules}"
              unless course.setup_modules
                open("http://#{global_options[:p]}/feeds/canvas_setup_modules/#{global_options[:k]}/#{course.website_id}") { |f|
                  f.each_line { |line| p line }
                }
                course.create_modules(client, c_course)
                course.setup_modules = true
              end

              if !course.setup && course.setup_frontpage && course.setup_modules # we have figured out that the course has been created on canvas
                #but presence does not know about this yet so we will mark it so in presence
                open("http://#{global_options[:p]}/feeds/canvas_setup/#{global_options[:k]}/#{course.website_id}") { |f|
                  f.each_line { |line| p line }
                }
                course.setup = true
              end
            end
          rescue Canvas::ApiError => error
            puts error
          end
        end
      end


      puts "canvas command ran"
    end
  end


  desc 'Enrollment conclude work for Canvas'
  command :canvas_conclude do |c|


    c.action do |global_options, options, args|

      # Your command logic here

      # If you have any errors, just raise them
      # raise "that command made no sense"
      puts global_options


      token = global_options[:t]
      hostname = global_options[:h]
      puts hostname

      client = Pandarus::Client.new(
          prefix: "https://#{hostname}/api",
          token: token)

      canvas = Canvas::API.new(:host => "https://#{hostname}", :token => token)

      files = Hash.new
      puts "cc----------------->loading feed files"
      load_files(files, 'canvas', global_options[:p], global_options[:i], global_options[:b], global_options[:y])

      @users = Hash.new
      puts "cc----------------->importing faculty"
      files[:offerings_xml].xpath("//faculty").each { |fac| Person.import_faculty_xml(fac, @users) }
      puts "cc----------------->total faculty: #{@users.count}"

      puts "cc----------------->importing terms"
      @terms = Term.import_xml files[:terms_xml], files[:lms_courses].xpath("//current_curricular_year").text.to_i
      #puts "----------------->importing users"
      #@users = Hash.new

      @enrollments_canvas = Array.new

      puts "cc----------------->extract settings from lms file"
      @settings = Settings.new(@lms_courses_xml)

      puts "cc----------------->importing sections"
      @sections = Section.import_xml files[:lms_courses], "CanvasCourse"
      @sections_csv = Section.sections_canvas_csv(@sections)
      puts "cc----------------->imported sections "

      puts "cc----------------->importing courses"
      @courses = Course.import_xml files[:lms_courses], "CanvasCourse", @sections, @users, @terms

      puts "cc----------------->extract settings from lms file"
      @settings = Settings.new(files[:lms_courses])

      puts "cc----------------->importing accounts"
      @accounts = Account.import_xml(files[:lms_courses], client)
      @accounts_csv = Account.accounts_canvas_csv(@accounts)
      #puts @courses
      #get people and enrollments

      puts "cc----->creating enrollments"
      @courses.values.each do |course|
        puts "---------->working on: #{course.long_name}"
        #course_created?(course.course_id,global_options)
        @enrollments_canvas = Enrollment.import_xml course, @enrollments_canvas, @users, global_options[:i], global_options[:b]
        puts "cc-------------------->course enrollments count: #{course.enrollments.count}"
      end


      @courses.values.each do |course|
        c_course = course.status_check(global_options, client)
        if course.created
          begin
            puts "cc----------------->Processing enrollment_term sections for rogue enrollements and removing them"
            #c_course = canvas.get("/api/v1/courses/sis_course_id:#{course.course_id}")
            puts "cc----->#{c_course}"
            #if c_course["id"]
            #  c_sections = canvas.get("/api/v1/courses/#{c_course["id"]}/sections")
            #puts "cc----->#{c_sections}"
            #get the one or two sections that are for current enrollment term and just process those two
            #binding.pry
            current_sections = course.sections.values.find_all { |section| section.current && section.control.eql?('full') }
            puts "cc----->current sections #{current_sections.length}"
            current_sections.compact.each do |section|
              c_section = client.get_section_information_sections("sis_section_id:#{section.section_id}")
              puts "cc----->current c_section #{c_section}"
              students = Hash.new #used to accumulate the enrollment to stop when we get the same students
              c_section_enrollment = client.list_enrollments_sections(c_section.id, {type: 'StudentEnrollment',
                                                                                     state: 'active'})
              puts c_section.name
              #while more
              c_section_enrollment.each do |c_enrollment|
                puts c_enrollment.user.sis_user_id
                user = @users[c_enrollment.user.sis_user_id]
                exists = @enrollments_canvas.detect { |enrollment| enrollment.match(user, section) }
                unless exists
                  puts "cc----->/api/v1/courses/#{c_enrollment['course_id']}/enrollments/#{c_enrollment['id']}?task=conclude"
                  begin
                    #binding.pry
                    del = client.conclude_enrollment(c_enrollment.course_id, c_enrollment.id, {task: "conclude"})
                  rescue => error
                    puts "++++++++++++>there was an error while processing for rogue enrollments #{error}<++++++++++++++++"
                    puts "++++++++++++>#{c_enrollment}"
                  end
                  puts "cc----->conclude user: #{user} resulted in #{del}"
                end

              end
            end
          rescue => error
            puts "++++++++++++>there was an error while processing for rogue enrollments #{error}<++++++++++++++++"
          end
        end
      end
      puts "canvas_conclude command ran"
    end
  end

  desc 'Enrollment conclude work for Canvas'
  command :canvas_end_of_term_conclude do |c|


    c.action do |global_options, options, args|

      # When a section is both no longer current and it
      puts global_options


      token = global_options[:t]
      hostname = global_options[:h]
      puts hostname

      client = Pandarus::Client.new(
          prefix: "https://#{hostname}/api",
          token: token)

      canvas = Canvas::API.new(:host => "https://#{hostname}", :token => token)

      files = Hash.new
      puts "cc----------------->loading feed files"
      load_files(files, 'canvas', global_options[:p], global_options[:i], global_options[:b], global_options[:y])

      @users = Hash.new
      puts "cc----------------->importing faculty"
      files[:offerings_xml].xpath("//faculty").each { |fac| Person.import_faculty_xml(fac, @users) }
      puts "cc----------------->total faculty: #{@users.count}"

      puts "cc----------------->importing terms"
      @terms = Term.import_xml files[:terms_xml], files[:lms_courses].xpath("//current_curricular_year").text.to_i
      #puts "----------------->importing users"
      #@users = Hash.new

      @enrollments_canvas = Array.new

      puts "cc----------------->importing sections"
      @sections = Section.import_xml files[:lms_courses], "CanvasCourse"
      @sections_csv = Section.sections_canvas_csv(@sections)
      puts "cc----------------->imported sections "

      puts "cc----------------->importing courses"
      @courses = Course.import_xml files[:lms_courses], "CanvasCourse", @sections, @users, @terms


      @conclude_enrollments = CSV.generate do |csv|
        csv << ["course_id", "user_id", "role", "section_id", "status", "associated_user_id"]
        @courses.values.each do |course|
          c_course = course.status_check(global_options, client)
          if course.created
            begin
              puts "cc----------------->Processing sections for concluded terms and concluding enrollments"
              puts "cc----------------->Sections #{course.sections}"
              current_sections = course.sections.values.find_all { |section| !section.current && ['full', 'add'].include?(section.control) }
              puts "cc----->current sections #{current_sections.length}"
              current_sections.compact.each do |section|
                c_section = client.get_section_information_sections("sis_section_id:#{section.section_id}")
                #puts "cc----->current c_section #{c_section}"
                c_section_enrollment = client.list_enrollments_sections(c_section.id, {type: 'StudentEnrollment',
                                                                                       state: 'active'})
                #puts c_section.name
                #while more
                c_section_enrollment.each do |c_enrollment|
                  #puts c_enrollment.user.sis_user_id
                  begin
                    #binding.pry
                    del = [section.course_id, c_enrollment['user']['sis_user_id'], 'Student', section.section_id, 'completed']
                    csv << del
                      #del = client.conclude_enrollment(c_enrollment.course_id, c_enrollment.id, {task: "conclude"})
                  rescue => error
                    puts "++++++++++++>there was an error while processing for rogue enrollments #{error}<++++++++++++++++"
                    puts "++++++++++++>#{c_enrollment}"
                  end
                  #puts "cc----->conclude user: #{c_enrollment.user.sis_user_id} resulted in #{del}"
                end
              end
            rescue => error
              puts "++++++++++++>there was an error while processing for rogue enrollments #{error}<++++++++++++++++"
            end
          end
        end
      end
      #binding.pry
      sis_data = {}
      sis_data[:enrollments] = @conclude_enrollments
      send_sis(sis_data, client)

      puts "canvas_end_of_term_conclude command ran"
    end
  end


  desc 'Add all faculty users to canvas'
  command :canvas_faculty_import do |c|
    c.action do |global_options, options, args|
      # Your command logic here

      # If you have any errors, just raise them
      # raise "that command made no sense"
      puts global_options

      token = global_options[:t]
      hostname = global_options[:h]
      client = Pandarus::Client.new(
          prefix: "https://#{hostname}/api",
          token: token)

      url = "http://#{global_options[:b]}/banner/public/offerings/export"
      puts url
      @offerings_xml = Nokogiri::XML(open(url))

      url = "http://#{global_options[:p]}/feeds/canvas/lms_courses.xml"
      puts url
      @lms_courses_xml = Nokogiri::XML(open(url))

      @users = Hash.new
      puts "----------------->importing faculty"
      @offerings_xml.xpath("//faculty").each { |fac| Person.import_faculty_xml(fac, @users) }
      puts "----------------->total faculty: #{@users.count}"

      @users_csv = Person.users_canvas_csv(@users)

      if global_options[:d]
        puts "----------------->debug mode so not talking to canvas host"
      else
        send_sis({users: @users_csv}, client)
      end
    end
    puts "canvas_faculty command ran"

  end

  desc 'Add all students canvas'
  command :canvas_students_import do |c|
    c.action do |global_options, options, args|

      # Your command logic here

      # If you have any errors, just raise them
      # raise "that command made no sense"
      puts global_options

      token = global_options[:t]
      hostname = global_options[:h]
      client = Pandarus::Client.new(
          prefix: "https://#{hostname}/api",
          token: token)

      url = "http://#{global_options[:b]}/banner/public/offerings/export"
      puts url
      @offerings_xml = Nokogiri::XML(open(url))

      url = "http://#{global_options[:p]}/feeds/current_offerings.xml"
      puts url
      @current_offerings_xml = Nokogiri::XML(open(url))


      @users = Hash.new
      puts "----------------->importing students"
      @offerings_xml.xpath("//oars_offering").each { |offering| Person.import_students_xml(offering, @users, global_options[:i], global_options[:b]) }
      puts "----------------->total students: #{@users.count}"

      @users_csv = Person.users_canvas_csv(@users)


      if global_options[:d]
        puts "----------------->debug mode so not talking to canvas host"
      else
        send_sis({users: @users_csv}, client)
      end
    end
    puts "canvas_students command ran"

  end


  pre do |global, command, options, args|
    # Pre logic here
    # Return true to proceed; false to abort and not call the
    # chosen command
    # Use skips_pre before a command to skip this block
    # on that command only
    true
  end

  post do |global, command, options, args|
    # Post logic here
    # Use skips_post before a command to skip this
    # block on that command only
  end

  on_error do |exception|
    # Error logic here
    # return false to skip default error handling
    true
  end

  exit run(ARGV)
end
