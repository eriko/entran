#!/usr/bin/env ruby
require 'gli'
#begin # XXX: Remove this begin/rescue before distributing your app
require 'entran'
require 'faraday'
require 'yaml'
require 'csv'
require 'open-uri'
require 'nokogiri'
require 'csv'
#require 'openssl'
require 'net/http/post/multipart'
require 'canvas-api'
#rescue LoadError
#  STDERR.puts "In development, you need to use `bundle exec bin/entran` to run your app"
#  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
#  STDERR.puts "Feel free to remove this message from bin/entran now"
#  exit 64
#end
#config_file '.entran.rc'

module Net
  class HTTP
    alias_method :original_use_ssl=, :use_ssl=

    def use_ssl=(flag)
      #self.ca_file = Rails.root.join('lib/ca-bundle.crt')
      self.verify_mode = OpenSSL::SSL::VERIFY_NONE
      self.original_use_ssl = flag
    end
  end
end


puts Time.now
include GLI::App
program_desc 'Translates enrollment data into various formats and feeds it to target systems'

config_file '.entran.rc'

puts config_file '.entran.rc'

version Entran::VERSION

desc 'debug disables any changes to edge systems'
switch [:d, :debug]


desc 'all users from ims file and not limited to request courses'
switch [:f, :full]

flag [:h, :hostname]
flag [:t, :token]
flag [:p, :presence]
flag [:k, :presence_key]
flag [:i, :ims_key]
flag [:c, :canvas_key]
flag [:b, :banner_host]
flag [:y, :year]

desc 'Enrollment work for Canvas'
command :canvas do |c|


  c.action do |global_options, options, args|

    # Your command logic here

    # If you have any errors, just raise them
    # raise "that command made no sense"
    puts global_options


    files = Hash.new
    puts "----------------->loading feed files"
    load_files(files, 'canvas', global_options[:p], global_options[:i], global_options[:b], global_options[:y])

    @users = Hash.new
    puts "----------------->importing faculty"
    files[:offerings_xml].xpath("//faculty").each { |fac| User.import_faculty_xml(fac, @users) }
    puts "----------------->total faculty: #{@users.count}"

    puts "----------------->importing terms"
    @terms = Term.import_xml files[:terms_xml], files[:lms_courses].xpath("//current_curricular_year").text.to_i
    #puts "----------------->importing users"
    #@users = Hash.new


    @enrollments_canvas = Array.new


    puts "----------------->importing sections"
    @sections = Section.import_xml files[:lms_courses], "CanvasCourse"
    @sections_csv = Section.sections_canvas_csv(@sections)
    puts "----------------->imported sections #{@sections_csv}"

    puts "----------------->importing courses"
    @courses = Course.import_xml files[:lms_courses], @terms, files[:ims], @catalogs, "CanvasCourse", @sections, @users
    puts "----------------->importing accounts"
    @accounts = Account.import_xml files[:lms_courses]
    @accounts_csv = Account.accounts_canvas_csv(@accounts)
    #puts @courses
    #get people and enrollments


    puts "----->creating enrollments"
    @courses.values.each do |course|
      puts "---------->working on: #{course.long_name}"
      #course_created?(course.course_id,global_options)
      @enrollments_canvas = Enrollment.import_xml course, @enrollments_canvas, @users, global_options[:i], global_options[:b]
      puts "-------------------->course enrollments count: #{course.enrollments.count}"
    end

    unless global_options[:f]
      puts "----------------->limiting users to requested courses"
      @users_csv = User.users_limited_canvas_csv(@enrollments_canvas)
    else
      puts "----------------->using all users from enrollment source"
      @users_csv = User.users_canvas_csv(@users)
    end

    puts "----------------->1 creating/updating courses"
    @canvases_csv = CanvasCourse.courses_csv(@courses, global_options)
    puts "----------------->2 creating/updating courses"

    token = global_options[:t]
    hostname = global_options[:h]
    canvas = Canvas::API.new(:host => "https://#{hostname}", :token => token)
    #binding.pry
    puts "----------------->Processing enrollment_term sections for rogue enrollements and removing them"
    @courses.values.each do |course|
      #puts "/api/v1/courses/sis_course_id:#{course.course_id}"
      c_courses = begin
                    puts course.course_id
        c_course = canvas.get("/api/v1/courses/sis_course_id:#{course.course_id}")
        #binding.pry
        if c_course["id"]
          #puts c_course
          #c_tabs = canvas.get("/api/v1/courses/#{c_course["id"]}/tabs")
          #puts c_tabs
          #puts "/api/v1/courses/#{c_course["id"]}/sections"
          c_sections = canvas.get("/api/v1/courses/#{c_course["id"]}/sections")
          #puts c_sections
          #get the one or two sections that are for current enrollment term and just process those two
          current_section = c_sections.detect { |c_section| c_section['sis_section_id'].eql? "#{course.banner_offering_id}-#{course.enrollment_term}" }
          current_cl_section = c_sections.detect { |c_section| c_section['sis_section_id'].eql? "#{course.banner_offering_id}-#{course.enrollment_term}-cl" }
          c_sections = [current_section, current_cl_section]
          c_sections.compact.each do |c_section|
            #puts c_section['sis_section_id']
            #puts "/api/v1/sections/#{c_section["id"]}/enrollments"
            c_section_enrollment = canvas.get("/api/v1/sections/#{c_section["id"]}/enrollments")
            #puts c_section_enrollment
            c_section_enrollment.each do |c_enrollment|
              #puts c_enrollment
              #binding.pry
              user = @users[c_enrollment['user']['sis_user_id']]
              #puts "sis_user_id #{c_enrollment['user']['sis_user_id']}"
              #puts user
              section = course.sections[c_section['sis_section_id']]
              exists = @enrollments_canvas.detect { |enrollment| enrollment.match(user, course, section) }
              unless exists
                puts "/api/v1/courses/sis_course_id:#{course.course_id}/enrollments/#{c_enrollment['id']}?task=conclude"
                del = canvas.delete(("/api/v1/courses/sis_course_id:#{course.course_id}/enrollments/#{c_enrollment['id']}?task=conclude"))
                puts "Delete user: #{user} resulted in #{del}"
              end
            end
          end
        end
      rescue => error
        puts "there was an error while processing for rogue enrollments #{error}"
      end
    end

    @enrollments_canvas_csv = Enrollment.enrollments_canvas_csv(@enrollments_canvas)
    puts "----------------->enrollments: #{@enrollments_canvas.count}"


    puts "creating SIS zip file"
    filename = "sis_#{Time.now.to_i.to_s}"
    fullpath = "/tmp/#{filename}.zip"
    puts fullpath
    puts "open /tmp/#{filename}.zip && sleep 2 && mate /tmp/#{filename}"
    Zip::Archive.open(fullpath, Zip::CREATE) do |ar|
      ar.add_buffer('users.csv', @users_csv);
      ar.add_buffer('terms.csv', files[:terms_csv].string);
      ar.add_buffer('sections.csv', @sections_csv);
      ar.add_buffer('accounts.csv', @accounts_csv);
      ar.add_buffer('courses.csv', @canvases_csv);
      ar.add_buffer('enrollments.csv', @enrollments_canvas_csv);
    end

    token = global_options[:t]
    hostname = global_options[:h]
    url = URI.parse("https://#{hostname}/api/v1/accounts/1/sis_imports.json?import_type=instructure_csv?extension=zip")
    puts url
    req = Net::HTTP::Post::Multipart.new url.path, "attachment" => UploadIO.new(fullpath, "application/zip", "#{filename}.zip")
    req.add_field("Authorization", "Bearer #{token}")
    n = Net::HTTP.new(url.host, url.port)
    n.use_ssl = true
    if global_options[:d]
      puts "----------------->debug mode so not talking to canvas host"
    else
      res = n.start do |http|
        http.request(req)
      end
      puts res
    end
    #File.delete(fullpath)


    puts "canvas command ran"
  end
end


desc 'Add all users to canvas'
command :canvas_setup do |c|
  c.action do |global_options, options, args|

    # Your command logic here

    # If you have any errors, just raise them
    # raise "that command made no sense"
    puts global_options


    files = Hash.new
    puts "----------------->loading feed files"
    load_files(files, 'canvas', global_options[:p], global_options[:i], global_options[:b], global_options[:y])

    puts "----------------->importing terms"
    @terms = Term.import_xml files[:terms_xml], files[:lms_courses].xpath("//current_curricular_year").text.to_i

    puts "----------------->importing courses"
    @courses = Course.import_xml files[:lms_courses], @terms, files[:ims], @catalogs, "CanvasCourse", @sections, @users

    puts "----------------->1 creating/updating courses"
    @canvases_csv = CanvasCourse.courses_csv(@courses, global_options)
    puts "----------------->2 creating/updating courses"

    token = global_options[:t]
    hostname = global_options[:h]
    canvas = Canvas::API.new(:host => "https://#{hostname}", :token => token)
    #binding.pry
    puts "----------------->Processing courses for creation and setup"
    @courses.values.each do |course|
      #puts "/api/v1/courses/sis_course_id:#{course.course_id}"

      puts "/api/v1/courses/sis_course_id:#{course.course_id}"
      begin
        c_course = canvas.get("/api/v1/courses/sis_course_id:#{course.course_id}")
        unless c_course['errors']
          #binding.pry

          if c_course["id"] && course.created == true && course.setup == false
            #create modules
            course.create_modules(canvas, c_course, hostname)
            #reorder nav tabs and hide some of them
            course.setup_tabs(canvas, c_course)

          end
        end
      rescue Canvas::ApiError => error
        puts error
        if course.created == true #&& error.eql?("The specified resource does not exist") # we have figured out that the course has been deleted so lets tell
          #presence about this
          #but presence does not know about this yet so we will mark it so in presence
          puts "marking course as uncreated"
          open("http://#{global_options[:p]}/feeds/canvas_uncreated/#{global_options[:k]}/#{course.website_id}") { |f|
            f.each_line { |line| p line }
          }
          course.created = true
        end
      end
    end
  end


#File.delete(fullpath)


  puts "canvas_setup command ran"

end
desc 'Add all users to canvas'
command :canvas_created do |c|
  c.action do |global_options, options, args|

    # Your command logic here

    # If you have any errors, just raise them
    # raise "that command made no sense"
    puts global_options


    files = Hash.new
    puts "----------------->loading feed files"
    load_files(files, 'canvas', global_options[:p], global_options[:i], global_options[:b], global_options[:y])

    puts "----------------->importing terms"
    @terms = Term.import_xml files[:terms_xml], files[:lms_courses].xpath("//current_curricular_year").text.to_i

    puts "----------------->importing courses"
    @courses = Course.import_xml files[:lms_courses], @terms, files[:ims], @catalogs, "CanvasCourse", @sections, @users

    puts "----------------->1 creating/updating courses"
    @canvases_csv = CanvasCourse.courses_csv(@courses, global_options)
    puts "----------------->2 creating/updating courses"

    token = global_options[:t]
    hostname = global_options[:h]
    canvas = Canvas::API.new(:host => "https://#{hostname}", :token => token)
    #binding.pry
    puts "----------------->Processing courses for creation and setup"
    @courses.values.each do |course|
      #puts "/api/v1/courses/sis_course_id:#{course.course_id}"

      puts "/api/v1/courses/sis_course_id:#{course.course_id}"
      begin
        c_course = canvas.get("/api/v1/courses/sis_course_id:#{course.course_id}")
        puts c_course
        if c_course["id"] && course.created == false # we have figured out that the course has been created on canvas
          #but presence does not know about this yet so we will mark it so in presence
          open("http://#{global_options[:p]}/feeds/canvas_created/#{global_options[:k]}/#{course.website_id}") { |f|
            f.each_line { |line| p line }
          }
          course.created = true
        end

      rescue Canvas::ApiError => error
        puts error
        if course.created == true #&& error.eql?("The specified resource does not exist") # we have figured out that the course has been deleted so lets tell
          #presence about this
          #but presence does not know about this yet so we will mark it so in presence
          #puts "http://#{global_options[:p]}/offerings/#{course.offering_id}/websites"
          open("http://#{global_options[:p]}/feeds/canvas_uncreated/#{global_options[:k]}/#{course.website_id}") { |f|
            f.each_line { |line| p line }
          }
          course.created = true
        end
      end
    end
  end


#File.delete(fullpath)


  puts "canvas_created command ran"

end


pre do |global, command, options, args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global, command, options, args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
