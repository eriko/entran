#!/usr/bin/env ruby
require 'gli'
#begin # XXX: Remove this begin/rescue before distributing your app
require 'entran'
require 'faraday'
require 'yaml'
require 'csv'
require 'open-uri'
require 'nokogiri'
require 'csv'
#require 'openssl'
require 'net/http/post/multipart'
#require 'canvas-api'
require 'pry'
require 'pandarus'
#rescue LoadError
#  STDERR.puts "In development, you need to use `bundle exec bin/entran` to run your app"
#  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
#  STDERR.puts "Feel free to remove this message from bin/entran now"
#  exit 64
#end
#config_file '.entran.rc'

module Net
  class HTTP
    alias_method :original_use_ssl=, :use_ssl=

    def use_ssl=(flag)
      #self.ca_file = Rails.root.join('lib/ca-bundle.crt')
      self.verify_mode = OpenSSL::SSL::VERIFY_NONE
      self.original_use_ssl = flag
    end
  end
end

module Wrapper
  include GLI::App

  extend self
  puts Time.now
  include GLI::App
  program_desc 'Translates enrollment data into various formats and feeds it to target systems'

  config_file '.entran.rc'

  puts config_file '.entran.rc'

  version Entran::VERSION

  desc 'debug disables any changes to edge systems'
  switch [:d, :debug]


  desc 'all users from ims file and not limited to request courses'
  switch [:f, :full]

  flag [:h, :hostname]
  flag [:t, :token]
  flag [:p, :presence]
  flag [:k, :presence_key]
  flag [:i, :ims_key]
  flag [:c, :canvas_key]
  flag [:b, :banner_host]
  flag [:y, :year]

  desc 'Enrollment work for Canvas'
  command :canvas do |c|


    c.action do |global_options, options, args|

      # Your command logic here

      # If you have any errors, just raise them
      # raise "that command made no sense"
      puts global_options


      token = global_options[:t]
      hostname = global_options[:h]
      puts hostname
      client = Pandarus::Client.new(
          prefix: "https://#{hostname}/api",
          token: token)

      canvas = Canvas::API.new(:host => "https://#{hostname}", :token => token)

      files = Hash.new
      puts "----------------->loading feed files"
      load_files(files, 'canvas', global_options[:p], global_options[:i], global_options[:b], global_options[:y])

      @users = Hash.new
      puts "----------------->importing faculty"
      files[:offerings_xml].xpath("//faculty").each { |fac| Person.import_faculty_xml(fac, @users) }
      puts "----------------->total faculty: #{@users.count}"

      puts "----------------->importing terms"
      @terms = Term.import_xml files[:terms_xml], files[:lms_courses].xpath("//current_curricular_year").text.to_i
      #puts "----------------->importing users"
      #@users = Hash.new

      @enrollments_canvas = Array.new

      puts "----------------->extract settings from lms file"
      @settings = Settings.new(@lms_courses_xml)

      puts "----------------->importing sections"
      @sections = Section.import_xml files[:lms_courses], "CanvasCourse"
      @sections_csv = Section.sections_canvas_csv(@sections)
      puts "----------------->imported sections "

      puts "----------------->importing courses"
      @courses = Course.import_xml files[:lms_courses], "CanvasCourse", @sections, @users, @terms

      puts "----------------->extract settings from lms file"
      @settings = Settings.new(files[:lms_courses])

      #binding.pry
      puts "----------------->importing accounts"
      @accounts = Account.import_xml(files[:lms_courses], canvas, client)
      puts @accounts
      @accounts_csv = Account.accounts_canvas_csv(@accounts)
      puts @accounts_csv
      #puts @courses
      #get people and enrollments


      puts "ene----->creating enrollments"
      @courses.values.each do |course|
        puts "ene---------->working on: #{course.long_name}"
        #course_created?(course.course_id,global_options)
        @enrollments_canvas = Enrollment.import_xml course, @enrollments_canvas, @users, global_options[:i], global_options[:b]
        puts "ene-------------------->course enrollments count: #{course.enrollments.count}"
      end

      unless global_options[:f]
        puts "enu----------------->limiting users to requested courses"
        @users_csv = Person.users_limited_canvas_csv(@enrollments_canvas)
      else
        puts "enu----------------->using all users from enrollment source"
        @users_csv = Person.users_canvas_csv(@users)
      end

      @courses.values.each do |course|
        course.status_check(global_options, client)
        puts "enc----------------->/api/v1/courses/sis_course_id:#{course.course_id}"
        begin
          unless course.created
            puts "enc----------------->Creating course that does not exist"
            puts "enc----------------->the offering course #{course.long_name.strip} does not exist so we are going to make it"
            puts "enc----------------->/api/v1/accounts/#{@accounts[course.account_id].id}/courses"
            binding.pry
            c_course = client.create_new_course("sis_account_id:#{course.account_id}",
                                                {
                                                    'course__sis_course_id__' => course.course_id,
                                                    'course__name__' => course.long_name,
                                                    'course__course_code__' => course.short_name,
                                                    'course__start_at__' => course.first_term.start_date.iso8601,
                                                    'course__allow_student_forum_attachments__' => true,
                                                    'course__term_id__' => course.real_term.c_id,
                                                    'course__syllabus_body__' => @settings.canvas_syllabus,

                                                }
            )
            puts "enc----------------->#{c_course}"
            #mark course created in presence
            open("http://#{global_options[:p]}/feeds/canvas_created/#{global_options[:k]}/#{course.website_id}/#{c_course["id"]}") { |f|
              f.each_line { |line| p "enc----------->#{line}" }
            }
            course.created = true
          end
        rescue Canvas::ApiError => error
          if error.to_s.include?('is already in use')
            puts "enc----------------->The course already existed but was deleted without changing the sis id #{error}"
            open("http://#{global_options[:p]}/feeds/canvas_blocked/#{global_options[:k]}/#{course.website_id}") { |f|
              f.each_line { |line| p "enc----------->#{line}" }
            }
          end
        end
      end

      @enrollments_canvas_csv = Enrollment.enrollments_canvas_csv(@enrollments_canvas)
      puts "ene-------------->enrollments: #{@enrollments_canvas.count}"


      puts "ene-------------->creating SIS zip file and uploading it"
      filename = "sis_#{Time.now.to_i.to_s}"
      fullpath = "/tmp/#{filename}.zip"
      puts fullpath
      puts "open /tmp/#{filename}.zip && sleep 2 && mate /tmp/#{filename}"
      Zip::Archive.open(fullpath, Zip::CREATE) do |ar|
        ar.add_buffer('users.csv', @users_csv);
        ar.add_buffer('terms.csv', files[:terms_csv].string);
        ar.add_buffer('sections.csv', @sections_csv);
        ar.add_buffer('accounts.csv', @accounts_csv);
        #ar.add_buffer('courses.csv', @canvases_csv);
        ar.add_buffer('enrollments.csv', @enrollments_canvas_csv);
      end

      token = global_options[:t]
      hostname = global_options[:h]
      url = URI.parse("https://#{hostname}/api/v1/accounts/1/sis_imports.json?import_type=instructure_csv?extension=zip")
      puts url
      req = Net::HTTP::Post::Multipart.new url.path, "attachment" => UploadIO.new(fullpath, "application/zip", "#{filename}.zip")
      req.add_field("Authorization", "Bearer #{token}")
      n = Net::HTTP.new(url.host, url.port)
      n.use_ssl = true
      if global_options[:d]
        puts "ene-------------->debug mode so not talking to canvas host"
      else
        res = n.start do |http|
          http.request(req)
        end
        puts res
      end
      unless global_options[:d]
        File.delete(fullpath)
      end

      puts "ensu------------>Processing courses for setup"
      @courses.values.each do |course|
        #the api can error out so we create each area separetely and mark each one
        #as worked on before starting to do the work so that at worst there is
        #something incomplete and not repeatly pounded on. If everything is marked assert_equal
        #as setup_* = true then mark the whole thing as setup.
        #binding.pry
        unless course.setup
          puts "ensu------------>/api/v1/courses/sis_course_id:#{course.course_id}"
          puts "ensu------------>course.created == #{course.created} && course.setup == #{course.setup}"
          #binding.pry
          begin
            c_course = client.get_single_course_courses("sis_course_id:#{self.course_id}")
            puts c_course
            if c_course.id && course.created == true && course.setup == false
              puts "ensu------------>setup frontpage = #{course.setup_frontpage}"
              unless course.setup_frontpage
                open("http://#{global_options[:p]}/feeds/canvas_setup_frontpage/#{global_options[:k]}/#{course.website_id}") { |f|
                  f.each_line { |line| p line }
                }
                course.create_frontpage(client, c_course, @settings.canvas_homepage)
                course.setup_frontpage = true
              end
              #create modules
              puts "ensu------------>course.setup_modules = #{course.setup_modules}"
              unless course.setup_modules
                open("http://#{global_options[:p]}/feeds/canvas_setup_modules/#{global_options[:k]}/#{course.website_id}") { |f|
                  f.each_line { |line| p line }
                }
                course.create_modules(canvas, c_course, @settings)
                course.setup_modules = true
              end
              #reorder nav tabs and hide some of them
              puts "ensu------------>setup setup_nav = #{course.setup_nav}"
              unless course.setup_nav
                open("http://#{global_options[:p]}/feeds/canvas_setup_nav/#{global_options[:k]}/#{course.website_id}") { |f|
                  f.each_line { |line| p line }
                }
                course.setup_tabs(canvas, c_course)
                course.setup_nav = true
              end
              if !course.setup && course.setup_frontpage && course.setup_modules && course.setup_nav # we have figured out that the course has been created on canvas
                #but presence does not know about this yet so we will mark it so in presence
                open("http://#{global_options[:p]}/feeds/canvas_setup/#{global_options[:k]}/#{course.website_id}") { |f|
                  f.each_line { |line| p line }
                }
                course.setup = true
              end
            end
          rescue Canvas::ApiError => error
            puts error
          end
        end
      end


      puts "canvas command ran"
    end
  end


  desc 'Enrollment conclude work for Canvas'
  command :canvas_conclude do |c|


    c.action do |global_options, options, args|

      # Your command logic here

      # If you have any errors, just raise them
      # raise "that command made no sense"
      puts global_options


      token = global_options[:t]
      hostname = global_options[:h]
      puts hostname

      client = Pandarus::Client.new(
          prefix: "https://#{hostname}/api",
          token: token)

      canvas = Canvas::API.new(:host => "https://#{hostname}", :token => token)

      files = Hash.new
      puts "cc----------------->loading feed files"
      load_files(files, 'canvas', global_options[:p], global_options[:i], global_options[:b], global_options[:y])

      @users = Hash.new
      puts "cc----------------->importing faculty"
      files[:offerings_xml].xpath("//faculty").each { |fac| Person.import_faculty_xml(fac, @users) }
      puts "cc----------------->total faculty: #{@users.count}"

      puts "cc----------------->importing terms"
      @terms = Term.import_xml files[:terms_xml], files[:lms_courses].xpath("//current_curricular_year").text.to_i
      #puts "----------------->importing users"
      #@users = Hash.new

      @enrollments_canvas = Array.new

      puts "cc----------------->extract settings from lms file"
      @settings = Settings.new(@lms_courses_xml)

      puts "cc----------------->importing sections"
      @sections = Section.import_xml files[:lms_courses], "CanvasCourse"
      @sections_csv = Section.sections_canvas_csv(@sections)
      puts "cc----------------->imported sections "

      puts "cc----------------->importing courses"
      @courses = Course.import_xml files[:lms_courses], "CanvasCourse", @sections, @users, @terms

      puts "cc----------------->extract settings from lms file"
      @settings = Settings.new(files[:lms_courses])

      puts "cc----------------->importing accounts"
      @accounts = Account.import_xml(files[:lms_courses], canvas, client)
      @accounts_csv = Account.accounts_canvas_csv(@accounts)
      #puts @courses
      #get people and enrollments

      puts "cc----->creating enrollments"
      @courses.values.each do |course|
        puts "---------->working on: #{course.long_name}"
        #course_created?(course.course_id,global_options)
        @enrollments_canvas = Enrollment.import_xml course, @enrollments_canvas, @users, global_options[:i], global_options[:b]
        puts "cc-------------------->course enrollments count: #{course.enrollments.count}"
      end


      @courses.values.each do |course|
        c_course = course.status_check(global_options, client)
        if course.created
          begin
            puts "cc----------------->Processing enrollment_term sections for rogue enrollements and removing them"
            #c_course = canvas.get("/api/v1/courses/sis_course_id:#{course.course_id}")
            puts "cc----->#{c_course}"
            #if c_course["id"]
            #  c_sections = canvas.get("/api/v1/courses/#{c_course["id"]}/sections")
            #puts "cc----->#{c_sections}"
            #get the one or two sections that are for current enrollment term and just process those two
            #binding.pry
            current_sections = course.sections.values.find_all { |section| section.current && section.control.eql?('full') }
            puts "cc----->current sections #{current_sections.length}"
            current_sections.compact.each do |section|
              c_section = client.get_section_information_sections("sis_section_id:#{section.section_id}")
              puts "cc----->current c_section #{c_section}"
              students = Hash.new #used to accumulate the enrollment to stop when we get the same students
              c_section_enrollment = client.list_enrollments_sections(c_section.id, {type: 'StudentEnrollment',
                                                                                     state: 'active'})
              if c_section_enrollment.length > 0 #accumulate all the enrollments for the section
                more = true
                while more
                  c_section_enrollment.each do |c_enrollment|
                    #binding.pry
                    sis_user_id = c_enrollment.user.sis_user_id
                    puts user
                    if students[sis_user_id]
                      more = false
                      break
                      #if we get a repeat stop
                    else
                      students[sis_user_id]= c_enrollment
                    end
                  end
                  c_section_enrollment = client.list_enrollments_sections(c_section.id,
                                                                          {type: 'StudentEnrollment',
                                                                           state: 'active',
                                                                           next_page: true})  if more

                  puts "cc----->there are more enrollments so looping" if more
                end
                binding.pry
                 unless students.empty?
                  students.values.each do |c_enrollment|
                    user = @users[c_enrollment.user.sis_user_id]
                    exists = @enrollments_canvas.detect { |enrollment| enrollment.match(user, section) }
                    unless exists
                      puts "cc----->/api/v1/courses/#{c_enrollment['course_id']}/enrollments/#{c_enrollment['id']}?task=conclude"
                      begin
                        binding.pry
                        del = client.conclude_enrollment(c_enrollment.course_id, c_enrollment.id, {task: "conclude"})
                      rescue => error
                        puts "++++++++++++>there was an error while processing for rogue enrollments #{error}<++++++++++++++++"
                        puts "++++++++++++>#{c_enrollment}"
                      end
                      puts "cc----->Delete user: #{user} resulted in #{del}"
                    end
                  end
                end
                # end
              end
            end
          rescue => error
            puts "++++++++++++>there was an error while processing for rogue enrollments #{error}<++++++++++++++++"
          end
        end
      end
      puts "canvas command ran"
    end
  end


  desc 'Add all faculty users to canvas'
  command :canvas_faculty_import do |c|
    c.action do |global_options, options, args|

      # Your command logic here

      # If you have any errors, just raise them
      # raise "that command made no sense"
      puts global_options

      token = global_options[:t]
      hostname = global_options[:h]
      url = "http://#{global_options[:b]}/banner/public/offerings/export"
      puts url
      @offerings_xml = Nokogiri::XML(open(url))

      url = "http://#{global_options[:p]}/feeds/canvas/lms_courses.xml"
      puts url
      @lms_courses_xml = Nokogiri::XML(open(url))


      @users = Hash.new
      puts "----------------->importing faculty"
      @offerings_xml.xpath("//faculty").each { |fac| Person.import_faculty_xml(fac, @users) }
      puts "----------------->total faculty: #{@users.count}"

      @users_csv = Person.users_canvas_csv(@users)




      puts "creating SIS zip file"
      filename = "sis_#{Time.now.to_i.to_s}"
      fullpath = "/tmp/#{filename}.zip"
      puts fullpath
      puts "open /tmp/#{filename}.zip && sleep 2 && mate /tmp/#{filename}"
      Zip::Archive.open(fullpath, Zip::CREATE) do |ar|
        ar.add_buffer('users.csv', @users_csv);
      end

      url = URI.parse("https://#{hostname}/api/v1/accounts/1/sis_imports.json?import_type=instructure_csv?extension=zip")
      puts url
      req = Net::HTTP::Post::Multipart.new url.path, "attachment" => UploadIO.new(fullpath, "application/zip", "#{filename}.zip")
      req.add_field("Authorization", "Bearer #{token}")
      n = Net::HTTP.new(url.host, url.port)
      n.use_ssl = true
      if global_options[:d]
        puts "----------------->debug mode so not talking to canvas host"
      else
        res = n.start do |http|
          http.request(req)
        end
        puts res
      end


      unless global_options[:d]
        File.delete(fullpath)
      end

    end


    puts "canvas_faculty command ran"

  end

  desc 'Add all students canvas'
  command :canvas_students_import do |c|
    c.action do |global_options, options, args|

      # Your command logic here

      # If you have any errors, just raise them
      # raise "that command made no sense"
      puts global_options

      token = global_options[:t]
      hostname = global_options[:h]
      url = "http://#{global_options[:b]}/banner/public/offerings/export"
      puts url
      @offerings_xml = Nokogiri::XML(open(url))

      url = "http://#{global_options[:p]}/feeds/current_offerings.xml"
      puts url
      @current_offerings_xml = Nokogiri::XML(open(url))


      @users = Hash.new
      puts "----------------->importing students"
      @offerings_xml.xpath("//oars_offering").each { |offering| Person.import_students_xml(offering, @users, global_options[:i], global_options[:b]) }
      puts "----------------->total students: #{@users.count}"

      @users_csv = Person.users_canvas_csv(@users)


      puts "creating SIS zip file"
      filename = "sis_#{Time.now.to_i.to_s}"
      fullpath = "/tmp/#{filename}.zip"
      puts fullpath
      puts "open /tmp/#{filename}.zip && sleep 2 && mate /tmp/#{filename}"
      Zip::Archive.open(fullpath, Zip::CREATE) do |ar|
        ar.add_buffer('users.csv', @users_csv);
      end

      url = URI.parse("https://#{hostname}/api/v1/accounts/1/sis_imports.json?import_type=instructure_csv?extension=zip")
      puts url
      req = Net::HTTP::Post::Multipart.new url.path, "attachment" => UploadIO.new(fullpath, "application/zip", "#{filename}.zip")
      req.add_field("Authorization", "Bearer #{token}")
      n = Net::HTTP.new(url.host, url.port)
      n.use_ssl = true
      if global_options[:d]
        puts "----------------->debug mode so not talking to canvas host"
      else
        res = n.start do |http|
          http.request(req)
        end
        puts res
      end


      unless global_options[:d]
        File.delete(fullpath)
      end

    end


    puts "canvas_students command ran"

  end


  pre do |global, command, options, args|
    # Pre logic here
    # Return true to proceed; false to abort and not call the
    # chosen command
    # Use skips_pre before a command to skip this block
    # on that command only
    true
  end

  post do |global, command, options, args|
    # Post logic here
    # Use skips_post before a command to skip this
    # block on that command only
  end

  on_error do |exception|
    # Error logic here
    # return false to skip default error handling
    true
  end

  exit run(ARGV)
end
